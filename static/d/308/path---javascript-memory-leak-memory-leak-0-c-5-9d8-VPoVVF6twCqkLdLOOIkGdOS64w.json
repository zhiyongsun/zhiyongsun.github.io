{"data":{"markdownRemark":{"html":"<h2 id=\"什么是内存泄漏？\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是内存泄漏？</h2>\n<p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。    </p>\n<p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>\n<p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</p>\n<p>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> buffer<span class=\"token punctuation\">;</span>\nbuffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Do something with buffer</span>\n\n<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n      </div>\n<p>上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。</p>\n<p>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"（garbage collector）。</p>\n<h2 id=\"垃圾回收机制\"><a href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>垃圾回收机制</h2>\n<p>垃圾回收机制怎么知道，哪些内存不再需要呢？</p>\n<p>最常使用的方法叫做\"引用计数\"（reference counting）：语言引擎有一张\"引用表\"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/memory-leak-37a2f866376481bb595bdadac94c19a7-e7fab.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; ; max-width: 273px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 98.16849816849815%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAABsklEQVQ4y5VTu4rCUBC9YGXlB8RCy3yAIEF7rf0M8SfyLfYWYhV8IBYRGxVJpeL7jeIDfLt7wiyz8caVdYrLzdw5M2fOTMSXyx6PB87FYtHpdA6HA3vcJtyu+/2Os1wu67q+2+0+AHOcpmlCiFwuh/vtdvsAjOhkMqmqqmmazOUdGBFU4Xw+93q96/WKROh8tVpROnd9wQWp5uVy6Xa7p9OJWYzH481m44x5ApNrNptZllWv14GXRGq3281ms9/vy5UpaLlcBgIBn8/XarWcTdLr8XiMRCLQDyNwvv6A0Zjf71cUBVmcZZlqLBYD2DAMp/i/tAGbz+cSYV6YyWSC5qfTKVi8EMx9IXrr9RpIcgKJQTAdwRwkMbnbwWBAd8oF5SkXnMK9ffSJIChcq9UwcGlzS6VSsVi0K6fTaWwFYySFMpkMK8QB0WgUT/l8HqeNh5cqMDiRSHg8nmq1ygWZYDwe93q9lUpFhEIh7AZFwBi83++Hw+HLzd9ut6PR6Gm3JdrO82UKWzAqSN5CoYBJcIq/fiZ+sjeM9Mhms+g/HA5LA39jgvVoNBrBYDCVSv0TCfsGgFpMX63Vv80AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"memory leak\"\n        title=\"\"\n        src=\"/static/memory-leak-37a2f866376481bb595bdadac94c19a7-e7fab.png\"\n        srcset=\"/static/memory-leak-37a2f866376481bb595bdadac94c19a7-05041.png 173w,\n/static/memory-leak-37a2f866376481bb595bdadac94c19a7-e7fab.png 273w\"\n        sizes=\"(max-width: 273px) 100vw, 273px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图中，左下角的两个值，没有任何引用，所以可以释放。</p>\n<p>如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello world'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n      </div>\n<p>上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。</p>\n<p>如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello world'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\narr <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre>\n      </div>\n<p>上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。</p>\n<p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p>\n<h2 id=\"几种类型的常见-javascript-内存泄露，以及解决方法\"><a href=\"#%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81-javascript-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>几种类型的常见 JavaScript 内存泄露，以及解决方法</h2>\n<ul>\n<li>意外的全局变量\nJavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window 。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    bar <span class=\"token operator\">=</span> <span class=\"token string\">\"this is a hidden global variable\"</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> </code></pre>\n      </div>\n<ul>\n<li>被遗忘的计时器或回调函数\n在 JavaScript 中使用 setInterval 非常平常。一段常见的代码：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> someResource <span class=\"token operator\">=</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Node'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token comment\">// 处理 node 和 someResource </span>\n        node<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>someResource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre>\n      </div>\n<ul>\n<li>脱离 DOM 的引用\n有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> elements <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n    button<span class=\"token punctuation\">:</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    image<span class=\"token punctuation\">:</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'image'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    text<span class=\"token punctuation\">:</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'text'</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">function</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    image<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">'http://some.url/image'</span><span class=\"token punctuation\">;</span> \n    button<span class=\"token punctuation\">.</span><span class=\"token function\">click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span>innerHTML<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token comment\">// 更多逻辑 </span>\n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">function</span> <span class=\"token function\">removeButton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token comment\">// 按钮是 body 的后代元素 </span>\n    document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token comment\">// 此时，仍旧存在一个全局的 #button 的引用 </span>\n    <span class=\"token comment\">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 </span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 <td> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <td> 以外的其它节点。实际情况并非如此：此<td> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 <td> 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。</p>","timeToRead":2,"excerpt":"什么是内存泄漏？ 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。     对于持续运行的服务进程（daemon…","frontmatter":{"title":"内存泄露","cover":null,"date":"2017-10-31T10:00:00.000Z","category":"JavaScript","tags":["memory leak"]},"fields":{"nextTitle":"mongodb安装","nextSlug":"/mongodb/mongodb/","prevTitle":"短链生成原理","prevSlug":"/skills/short-url/","slug":"/javascript/memory-leak/memoryLeak/","date":"2017-10-30T16:00:00.000Z"}}},"pageContext":{"slug":"/javascript/memory-leak/memoryLeak/"}}