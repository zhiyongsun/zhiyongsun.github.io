{"data":{"allMarkdownRemark":{"totalCount":11,"edges":[{"node":{"fields":{"slug":"/books/ECMAScript6/10-object-function/","date":"2018-12-10T16:00:00.000Z"},"excerpt":"Object.is() ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript…","timeToRead":2,"frontmatter":{"title":"对象的新增方法","tags":["books"],"cover":null,"date":"2018-12-11T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/ECMAScript6/9-object/","date":"2018-12-10T16:00:00.000Z"},"excerpt":"对象的扩展 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 object Object ，这一点要特别小心。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name…","timeToRead":4,"frontmatter":{"title":"对象的扩展","tags":["books"],"cover":null,"date":"2018-12-11T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/ECMAScript6/2-destructuring/","date":"2018-12-04T16:00:00.000Z"},"excerpt":"数组的解构赋值 基本用法 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator…","timeToRead":5,"frontmatter":{"title":"变量的结构赋值","tags":["books"],"cover":null,"date":"2018-12-05T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/ECMAScript6/3-string/","date":"2018-12-04T16:00:00.000Z"},"excerpt":"仅为个人读书笔记，原书  http://es6.ruanyifeng.com/","timeToRead":1,"frontmatter":{"title":"字符串的扩展","tags":["books"],"cover":null,"date":"2018-12-05T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/ECMAScript6/6-number/","date":"2018-12-04T16:00:00.000Z"},"excerpt":"Math 对象的扩展 ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。 Math.trunc() Math.trunc方法用于去除一个数的小数部分，返回整数部分。\n     Math.sign() Math…","timeToRead":1,"frontmatter":{"title":"数值的扩展","tags":["books"],"cover":null,"date":"2018-12-05T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/ECMAScript6/7-function/","date":"2018-12-04T16:00:00.000Z"},"excerpt":"函数参数的默认值 一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 10…","timeToRead":6,"frontmatter":{"title":"函数参数的默认值","tags":["books"],"cover":null,"date":"2018-12-05T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/ECMAScript6/8-array/","date":"2018-12-04T16:00:00.000Z"},"excerpt":"扩展运算符 如果扩展运算符后面是一个空数组，则不产生任何效果。 注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用，否则就会报错。 扩展运算符的应用 Array.from() Array.from…","timeToRead":3,"frontmatter":{"title":"array 的扩展","tags":["books"],"cover":null,"date":"2018-12-05T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/ECMAScript6/1-let-and-const/","date":"2018-12-03T16:00:00.000Z"},"excerpt":"let 命令 声明的变量，只在let命令所在的代码块内有效。 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding…","timeToRead":4,"frontmatter":{"title":"let 和 const 命令","tags":["books"],"cover":null,"date":"2018-12-04T10:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/javascript-guide/","date":"2017-01-19T16:00:00.000Z"},"excerpt":"JavaScript权威指南 4. 表达式和运算符 4.2对象和数组的初始化表达式 数组直接量的元素列表结尾处可以留下单个都好,这时候并不会创建一个新的值为undefined的元素 4.10 逻辑表达式 4.10.1 逻辑与(&&) 4.11 赋值表达式 带操作的赋值运算 在a…","timeToRead":1,"frontmatter":{"title":"JavaScript权威指南读书笔记","tags":["books"],"cover":null,"date":"2017-01-20T22:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/react in-depth/","date":"2017-01-19T16:00:00.000Z"},"excerpt":"1 React Life Cycle Methods Overview Birth / Mounting Initialize / Construction getDefaultProps() (React.createClass) or MyComponent…","timeToRead":1,"frontmatter":{"title":"react-indepth 读书笔记","tags":["books"],"cover":null,"date":"2017-01-20T22:00:00.000Z"}}},{"node":{"fields":{"slug":"/books/the-three-body-problem/","date":"2017-01-19T16:00:00.000Z"},"excerpt":"刚刚看完三体三部曲，仅存的记忆写几个名词。 黑暗深林 二向箔","timeToRead":1,"frontmatter":{"title":"三体读书笔记","tags":["books"],"cover":null,"date":"2017-01-20T22:00:00.000Z"}}}]}},"pageContext":{"category":"books"}}